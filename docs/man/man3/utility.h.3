.TH "src/include/omega_edit/utility.h" 3 "Thu Mar 3 2022" "Version 0.8.1" "omega_edit" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/include/omega_edit/utility.h
.SH SYNOPSIS
.br
.PP
\fC#include 'byte\&.h'\fP
.br
\fC#include 'export\&.h'\fP
.br
\fC#include 'filesystem\&.h'\fP
.br
\fC#include <stdint\&.h>\fP
.br
\fC#include <stdio\&.h>\fP
.br

.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef \fBomega_byte_t\fP(* \fBomega_util_byte_transform_t\fP) (\fBomega_byte_t\fP, void *user_data)"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBomega_mask_kind_t\fP { \fBMASK_AND\fP, \fBMASK_OR\fP, \fBMASK_XOR\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBOMEGA_EDIT_EXPORT\fP char \fBomega_util_directory_separator\fP ()"
.br
.ti -1c
.RI "\fBOMEGA_EDIT_EXPORT\fP int \fBomega_util_mkstemp\fP (char *tmpl)"
.br
.ti -1c
.RI "\fBOMEGA_EDIT_EXPORT\fP int64_t \fBomega_util_write_segment_to_file\fP (FILE *from_file_ptr, int64_t offset, int64_t byte_count, FILE *to_file_ptr)"
.br
.ti -1c
.RI "\fBOMEGA_EDIT_EXPORT\fP int \fBomega_util_left_shift_buffer\fP (\fBomega_byte_t\fP *buffer, int64_t len, \fBomega_byte_t\fP shift_left)"
.br
.ti -1c
.RI "\fBOMEGA_EDIT_EXPORT\fP int \fBomega_util_right_shift_buffer\fP (\fBomega_byte_t\fP *buffer, int64_t len, \fBomega_byte_t\fP shift_right)"
.br
.ti -1c
.RI "\fBOMEGA_EDIT_EXPORT\fP void \fBomega_util_apply_byte_transform\fP (\fBomega_byte_t\fP *buffer, int64_t len, \fBomega_util_byte_transform_t\fP transform, void *user_data_ptr)"
.br
.ti -1c
.RI "\fBOMEGA_EDIT_EXPORT\fP int \fBomega_util_apply_byte_transform_to_file\fP (char const *in_path, char const *out_path, \fBomega_util_byte_transform_t\fP transform, void *user_data_ptr, int64_t offset, int64_t length)"
.br
.ti -1c
.RI "\fBOMEGA_EDIT_EXPORT\fP \fBomega_byte_t\fP \fBomega_util_mask_byte\fP (\fBomega_byte_t\fP byte, \fBomega_byte_t\fP mask, \fBomega_mask_kind_t\fP mask_kind)"
.br
.in -1c
.SH "Typedef Documentation"
.PP 
.SS "typedef \fBomega_byte_t\fP(* omega_util_byte_transform_t) (\fBomega_byte_t\fP, void *user_data)"
Byte transform function pointer 
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBomega_mask_kind_t\fP"
Mask types 
.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIMASK_AND \fP\fP
.TP
\fB\fIMASK_OR \fP\fP
.TP
\fB\fIMASK_XOR \fP\fP
.SH "Function Documentation"
.PP 
.SS "\fBOMEGA_EDIT_EXPORT\fP void omega_util_apply_byte_transform (\fBomega_byte_t\fP * buffer, int64_t len, \fBomega_util_byte_transform_t\fP transform, void * user_data_ptr)"
Apply the given transform to bytes in the given buffer 
.PP
\fBParameters\fP
.RS 4
\fIbuffer\fP buffer of bytes to apply the transform to 
.br
\fIlen\fP number of bytes in the buffer to apply the transform to 
.br
\fItransform\fP transform function to apply to the bytes in the buffer 
.br
\fIuser_data_ptr\fP pointer to user-defined data to associate with the transformer 
.RE
.PP

.SS "\fBOMEGA_EDIT_EXPORT\fP int omega_util_apply_byte_transform_to_file (char const * in_path, char const * out_path, \fBomega_util_byte_transform_t\fP transform, void * user_data_ptr, int64_t offset, int64_t length)"
Apply the given transform to the input file and write the transformed data to the output file 
.PP
\fBParameters\fP
.RS 4
\fIin_path\fP path of the file to apply the transform to 
.br
\fIout_path\fP path of the file to write the transformed data to 
.br
\fItransform\fP byte transform function to apply 
.br
\fIuser_data_ptr\fP pointer to user-defined data to associate with the transformer 
.br
\fIoffset\fP where to begin transforming bytes 
.br
\fIlength\fP number of bytes to transform from the given offset 
.RE
.PP
\fBReturns\fP
.RS 4
zero on success, non-zero on failure 
.RE
.PP

.SS "\fBOMEGA_EDIT_EXPORT\fP char omega_util_directory_separator ()"
Returns the directory separator character used on the host system 
.PP
\fBReturns\fP
.RS 4
directory separator character used on the host system 
.RE
.PP

.SS "\fBOMEGA_EDIT_EXPORT\fP int omega_util_left_shift_buffer (\fBomega_byte_t\fP * buffer, int64_t len, \fBomega_byte_t\fP shift_left)"
Shift the bits of the given buffer by a given number of bits to the left 
.PP
\fBParameters\fP
.RS 4
\fIbuffer\fP pointer to the start of the buffer 
.br
\fIlen\fP length of the buffer 
.br
\fIshift_left\fP number of bits (greater than 0 and less than 8) to shift to the left 
.RE
.PP
\fBReturns\fP
.RS 4
zero on success, non-zero on failure 
.RE
.PP

.SS "\fBOMEGA_EDIT_EXPORT\fP \fBomega_byte_t\fP omega_util_mask_byte (\fBomega_byte_t\fP byte, \fBomega_byte_t\fP mask, \fBomega_mask_kind_t\fP mask_kind)"
Apply the given mask of the given mask kind to the given byte 
.PP
\fBParameters\fP
.RS 4
\fIbyte\fP byte to mask 
.br
\fImask\fP mask to apply 
.br
\fImask_kind\fP mask kind (e\&.g\&., MASK_AND, MASK_OR, MASK_XOR) 
.RE
.PP
\fBReturns\fP
.RS 4
masked byte 
.RE
.PP

.SS "\fBOMEGA_EDIT_EXPORT\fP int omega_util_mkstemp (char * tmpl)"
Generate a temporary file name based on tmpl\&. The name constructed does not exist at the time of the call\&. The tmpl parameter is overwritten with the result\&. 
.PP
\fBParameters\fP
.RS 4
\fItmpl\fP must match the rules for mk[s]temp (i\&.e\&. end in 'XXXXXX') 
.RE
.PP
\fBReturns\fP
.RS 4
read-write file descriptor opened with mode 0600 modulo umask or -1 with errno set on error 
.RE
.PP

.SS "\fBOMEGA_EDIT_EXPORT\fP int omega_util_right_shift_buffer (\fBomega_byte_t\fP * buffer, int64_t len, \fBomega_byte_t\fP shift_right)"
Shift the bits of the given buffer by a given number of bits to the right 
.PP
\fBParameters\fP
.RS 4
\fIbuffer\fP pointer to the start of the buffer 
.br
\fIlen\fP length of the buffer 
.br
\fIshift_right\fP number of bits (greater than 0 and less than 8) to shift to the right 
.RE
.PP
\fBReturns\fP
.RS 4
zero on success, non-zero on failure 
.RE
.PP

.SS "\fBOMEGA_EDIT_EXPORT\fP int64_t omega_util_write_segment_to_file (FILE * from_file_ptr, int64_t offset, int64_t byte_count, FILE * to_file_ptr)"
Write a segment from one file into another file 
.PP
\fBParameters\fP
.RS 4
\fIfrom_file_ptr\fP from file pointer, opened for read 
.br
\fIoffset\fP where in the from file to begin reading from 
.br
\fIbyte_count\fP number of bytes to read from the from file starting at the given offset 
.br
\fIto_file_ptr\fP to file pointer, opened for writing and positioned to where to write the segment to 
.RE
.PP
\fBReturns\fP
.RS 4
number of bytes that where successfully written 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for omega_edit from the source code\&.
